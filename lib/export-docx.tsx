// DOCX Export utility using pure JavaScript
// Creates valid .docx files without external dependencies

interface DocxContent {
  title: string
  content: string
  keywords: string[]
  createdAt: string
}

function escapeXml(text: string): string {
  return text
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&apos;")
}

function markdownToDocxParagraphs(markdown: string): string {
  const lines = markdown.split("\n")
  let paragraphs = ""

  for (const line of lines) {
    const trimmedLine = line.trim()

    if (!trimmedLine) {
      paragraphs += `<w:p><w:r><w:t></w:t></w:r></w:p>`
      continue
    }

    // H1
    if (trimmedLine.startsWith("# ")) {
      const text = escapeXml(trimmedLine.slice(2))
      paragraphs += `<w:p><w:pPr><w:pStyle w:val="Heading1"/></w:pPr><w:r><w:rPr><w:b/><w:sz w:val="32"/></w:rPr><w:t>${text}</w:t></w:r></w:p>`
    }
    // H2
    else if (trimmedLine.startsWith("## ")) {
      const text = escapeXml(trimmedLine.slice(3))
      paragraphs += `<w:p><w:pPr><w:pStyle w:val="Heading2"/></w:pPr><w:r><w:rPr><w:b/><w:sz w:val="28"/></w:rPr><w:t>${text}</w:t></w:r></w:p>`
    }
    // H3
    else if (trimmedLine.startsWith("### ")) {
      const text = escapeXml(trimmedLine.slice(4))
      paragraphs += `<w:p><w:pPr><w:pStyle w:val="Heading3"/></w:pPr><w:r><w:rPr><w:b/><w:sz w:val="24"/></w:rPr><w:t>${text}</w:t></w:r></w:p>`
    }
    // List items
    else if (trimmedLine.match(/^[-*]\s/) || trimmedLine.match(/^\d+\.\s/)) {
      const text = escapeXml(trimmedLine.replace(/^[-*\d.]+\s+/, ""))
      paragraphs += `<w:p><w:pPr><w:ind w:left="720"/></w:pPr><w:r><w:t>â€¢ ${text}</w:t></w:r></w:p>`
    }
    // Bold text handling
    else if (trimmedLine.includes("**")) {
      let processed = trimmedLine
      const boldParts: string[] = []
      let match
      const boldRegex = /\*\*(.*?)\*\*/g
      let lastIndex = 0

      while ((match = boldRegex.exec(processed)) !== null) {
        if (match.index > lastIndex) {
          boldParts.push(`<w:r><w:t>${escapeXml(processed.slice(lastIndex, match.index))}</w:t></w:r>`)
        }
        boldParts.push(`<w:r><w:rPr><w:b/></w:rPr><w:t>${escapeXml(match[1])}</w:t></w:r>`)
        lastIndex = match.index + match[0].length
      }
      if (lastIndex < processed.length) {
        boldParts.push(`<w:r><w:t>${escapeXml(processed.slice(lastIndex))}</w:t></w:r>`)
      }

      paragraphs += `<w:p>${boldParts.join("")}</w:p>`
    }
    // Horizontal rule
    else if (trimmedLine === "---" || trimmedLine === "***") {
      paragraphs += `<w:p><w:pPr><w:pBdr><w:bottom w:val="single" w:sz="6" w:space="1" w:color="auto"/></w:pBdr></w:pPr></w:p>`
    }
    // Regular paragraph
    else {
      const text = escapeXml(trimmedLine.replace(/\*\*/g, ""))
      paragraphs += `<w:p><w:r><w:t>${text}</w:t></w:r></w:p>`
    }
  }

  return paragraphs
}

export async function exportToDocx(data: DocxContent): Promise<void> {
  const contentParagraphs = markdownToDocxParagraphs(data.content)

  // Keywords section
  const keywordsText = data.keywords.length > 0 ? data.keywords.join(", ") : "N/A"

  const documentXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
  <w:body>
    ${contentParagraphs}
    <w:p><w:r><w:t></w:t></w:r></w:p>
    <w:p><w:pPr><w:pBdr><w:top w:val="single" w:sz="6" w:space="1" w:color="auto"/></w:pBdr></w:pPr></w:p>
    <w:p><w:r><w:rPr><w:b/></w:rPr><w:t>Keywords: </w:t></w:r><w:r><w:t>${escapeXml(keywordsText)}</w:t></w:r></w:p>
    <w:p><w:r><w:rPr><w:i/><w:color w:val="666666"/></w:rPr><w:t>Generated by HINAI Tech on ${escapeXml(data.createdAt)}</w:t></w:r></w:p>
    <w:sectPr>
      <w:pgSz w:w="12240" w:h="15840"/>
      <w:pgMar w:top="1440" w:right="1440" w:bottom="1440" w:left="1440"/>
    </w:sectPr>
  </w:body>
</w:document>`

  const contentTypesXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="xml" ContentType="application/xml"/>
  <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
</Types>`

  const relsXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
</Relationships>`

  // Create ZIP file using JSZip-like approach with raw implementation
  const { default: JSZip } = await import("jszip")
  const zip = new JSZip()

  zip.file("[Content_Types].xml", contentTypesXml)
  zip.file("_rels/.rels", relsXml)
  zip.file("word/document.xml", documentXml)

  const blob = await zip.generateAsync({ type: "blob", mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document" })

  // Download the file
  const url = URL.createObjectURL(blob)
  const a = document.createElement("a")
  a.href = url
  a.download = `${data.title.slice(0, 50).replace(/[^a-zA-Z0-9\s-]/g, "").replace(/\s+/g, "-")}.docx`
  document.body.appendChild(a)
  a.click()
  document.body.removeChild(a)
  URL.revokeObjectURL(url)
}
